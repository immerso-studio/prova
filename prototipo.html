<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D POV Interactive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Importante per mobile */
        }

        .gamepad-container {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2);
            display: none;
            align-items: center;
            justify-content: center;
            touch-action: none;
            user-select: none;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .gamepad-container {
                display: flex;
            }
        }

        .gamepad-stick {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.15);
            position: absolute;
            transition: all 0.1s ease;
            cursor: pointer;
        }

        .gamepad-stick:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        /* Stili rimanenti invariati... */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 500px;
            padding: 30px;
            color: white;
            position: relative;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .modal-title {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .modal-image {
            width: 100%;
            height: 200px;
            border-radius: 12px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            background-size: cover;
            background-position: center;
        }

        .modal-text {
            line-height: 1.6;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
        }

        .desktop-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 50;
        }

        @media (min-width: 769px) {
            .desktop-indicator {
                opacity: 1;
                animation: delayedFadeIn 0.5s ease 2s forwards;
            }
        }

        @keyframes delayedFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #87ceeb;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loader-content {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .loader-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cubes-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 200;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        @media (min-width: 769px) {
            .cubes-menu {
                opacity: 1;
                animation: delayedFadeIn 0.5s ease 2s forwards;
            }
        }

        .cubes-menu h3 {
            color: white;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 600;
        }

        .cube-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .cube-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .cube-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .cube-item.active {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            width: 40px;
            height: 40px;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            z-index: 201;
            font-size: 18px;
        }

        @media (max-width: 768px) {
            .menu-toggle {
                display: flex;
            }
            
            .cubes-menu {
                top: 70px;
                left: 20px;
                right: 20px;
                display: none;
            }
            
            .cubes-menu.mobile-open {
                display: block;
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="loader-content">
            <div class="loader-spinner"></div>
            <div>Caricamento scena 3D...</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div class="gamepad-container" id="gamepad">
        <div class="gamepad-stick" id="stick"></div>
    </div>

    <div class="menu-toggle" id="menu-toggle">â˜°</div>

    <div class="cubes-menu" id="cubes-menu">
        <h3>Seleziona Cubo</h3>
        <div class="cube-list" id="cube-list">
            <!-- I cubi verranno aggiunti dinamicamente via JavaScript -->
        </div>
    </div>

    <div class="desktop-indicator">
        Usa WASD per muoverti e il mouse per guardarti intorno
    </div>

    <div class="modal" id="modal">
        <div class="modal-content">
            <button class="modal-close" id="modal-close">&times;</button>
            <h2 class="modal-title" id="modal-title">Informazioni sul Cubo</h2>
            <div class="modal-image" id="modal-image"></div>
            <p class="modal-text" id="modal-text">
                Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/DRACOLoader.js"></script>
    <script>
        let scene, camera, renderer, plane;
        let playerPos = { x: 0, z: 0 };
        let velocity = { x: 0, z: 0 };
        
        // Camera rotation
        let cameraRotation = { yaw: 0, pitch: 0 };
        let isRotating = false;
        let lastTouchPos = { x: 0, y: 0 };
        
        // Gamepad variables
        let isDragging = false;
        let stickPos = { x: 0, y: 0 };
        const maxDistance = 60;

        // Controllo dispositivo
        let isMobile = window.innerWidth <= 768;

        // Tasti per movimento desktop
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // Raycaster per l'interazione con il cubo
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Variabile per tracciare il primo render
        let firstRenderDone = false;

        // Array dei cubi
        let cubes = [];
        let cubeLights = [];
        let currentModalCube = null;

        // Variabili per gestire il tap su mobile
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        const TAP_MAX_DURATION = 300; // ms
        const TAP_MAX_DISTANCE = 10; // px

        // Dettagli dei cubi
        const cubeData = [
            {
                id: 'cube1',
                name: 'Cubo Blu Tecnologico',
                position: { x: 5, y: 1, z: 5 },
                color: 0x3498db,
                lightColor: 0x3498db,
                description: 'Un cubo blu che rappresenta la tecnologia avanzata e l\'innovazione. Realizzato con materiali ad alta conducibilitÃ  e dotato di sistemi di illuminazione integrata.',
                imageStyle: 'background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%);'
            },
            {
                id: 'cube2',
                name: 'Cubo Rosso Energico',
                position: { x: -8, y: 1, z: -5 },
                color: 0xe74c3c,
                lightColor: 0xe74c3c,
                description: 'Cubo rosso simbolo di energia e passione. Emette un calore costante ed Ã¨ composto da leghe metalliche speciali resistenti alle alte temperature.',
                imageStyle: 'background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);'
            },
            {
                id: 'cube3',
                name: 'Cubo Verde Naturale',
                position: { x: -12, y: 1, z: 8 },
                color: 0x2ecc71,
                lightColor: 0x2ecc71,
                description: 'Cubo verde che emana un senso di pace e natura. Costituito da materiali organici e biodegradabili, rappresenta l\'armonia con l\'ambiente.',
                imageStyle: 'background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);'
            },
            {
                id: 'cube4',
                name: 'Cubo Viola Misterioso',
                position: { x: 15, y: 1, z: -10 },
                color: 0x9b59b6,
                lightColor: 0x9b59b6,
                description: 'Cubo viola avvolto nel mistero. Le sue proprietÃ  uniche includono la capacitÃ  di cambiare forma in base alla luce ambientale e alle condizioni atmosferiche.',
                imageStyle: 'background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);'
            }
        ];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 150);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.domElement.style.touchAction = 'none'; // Importante per mobile
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // Ground plane
            const planeGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const planeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a9d4a,
                roughness: 0.8,
                metalness: 0.2
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 50, 0x000000, 0x333333);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Creazione dei cubi
            createCubes();

            // Preload del decoder DRACO
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.1/');
            
            const loader = new THREE.GLTFLoader();
            loader.setDRACOLoader(dracoLoader);
            
            loader.load(
                'assets/Edifici cucinati 2K carta.glb',
                function(gltf) {
                    const model = gltf.scene;
                    
                    // Enable shadows for the model
                    model.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    // Position the model (adjust as needed)
                    model.position.set(0, 0, 0);
                    
                    scene.add(model);
                    console.log('Modello edifici caricato con successo!');
                },
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% caricato');
                },
                function(error) {
                    console.error('Errore nel caricamento del modello:', error);
                    hideLoader();
                }
            );

            // Setup controlli in base al dispositivo
            if (isMobile) {
                setupGamepad();
            } else {
                setupDesktopControls();
            }
            
            // Camera rotation events - SEMPRE ATTIVI SIA PER MOBILE CHE DESKTOP
            setupCameraRotation();

            // Modal events
            setupModal();

            // Menu events
            setupMenu();

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Click event per i cubi
            setupCubeInteractions();

            animate();
        }

        function createCubes() {
            cubeData.forEach((data, index) => {
                // Creazione del cubo
                const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
                const cubeMaterial = new THREE.MeshStandardMaterial({ 
                    color: data.color,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(data.position.x, data.position.y, data.position.z);
                cube.castShadow = true;
                cube.receiveShadow = true;
                cube.userData = { id: data.id, index: index };
                scene.add(cube);
                cubes.push(cube);

                // Luce per il cubo
                const cubeLight = new THREE.PointLight(data.lightColor, 0.5, 10);
                cubeLight.position.set(data.position.x, data.position.y + 3, data.position.z);
                scene.add(cubeLight);
                cubeLights.push(cubeLight);

                // Aggiungi al menu
                addCubeToMenu(data, index);
            });
        }

        function addCubeToMenu(data, index) {
            const cubeList = document.getElementById('cube-list');
            const cubeItem = document.createElement('div');
            cubeItem.className = 'cube-item';
            cubeItem.textContent = data.name;
            cubeItem.addEventListener('click', () => {
                teleportToCube(index);
                if (isMobile) {
                    toggleMobileMenu(false);
                }
            });
            cubeList.appendChild(cubeItem);
        }

        function teleportToCube(cubeIndex) {
            const cube = cubes[cubeIndex];
            const data = cubeData[cubeIndex];
            
            if (cube) {
                // Calcola la posizione di teletrasporto (2 unitÃ  di distanza dal cubo)
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                playerPos.x = data.position.x - direction.x * 3;
                playerPos.z = data.position.z - direction.z * 3;
                
                // Aggiorna la posizione della camera
                camera.position.x = playerPos.x;
                camera.position.z = playerPos.z;
                
                // Highlight nel menu
                highlightSelectedCube(cubeIndex);
                
                console.log(`Teletrasportato al cubo: ${data.name}`);
            }
        }

        function highlightSelectedCube(selectedIndex) {
            const cubeItems = document.querySelectorAll('.cube-item');
            cubeItems.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        function setupMenu() {
            const menuToggle = document.getElementById('menu-toggle');
            const cubesMenu = document.getElementById('cubes-menu');
            
            menuToggle.addEventListener('click', () => {
                toggleMobileMenu();
            });
        }

        function toggleMobileMenu(show) {
            const cubesMenu = document.getElementById('cubes-menu');
            if (show === undefined) {
                show = !cubesMenu.classList.contains('mobile-open');
            }
            
            if (show) {
                cubesMenu.classList.add('mobile-open');
            } else {
                cubesMenu.classList.remove('mobile-open');
            }
        }

        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.opacity = '0';
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 500);
            }
        }

        function setupDesktopControls() {
            // Event listener per i tasti
            document.addEventListener('keydown', function(event) {
                if (keys.hasOwnProperty(event.key)) {
                    keys[event.key] = true;
                }
            });

            document.addEventListener('keyup', function(event) {
                if (keys.hasOwnProperty(event.key)) {
                    keys[event.key] = false;
                }
            });
        }

        function setupModal() {
            const modal = document.getElementById('modal');
            const closeBtn = document.getElementById('modal-close');

            closeBtn.addEventListener('click', function() {
                modal.style.display = 'none';
                currentModalCube = null;
            });

            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    currentModalCube = null;
                }
            });
        }

        function showModal(cubeIndex) {
            const data = cubeData[cubeIndex];
            const modal = document.getElementById('modal');
            const modalTitle = document.getElementById('modal-title');
            const modalImage = document.getElementById('modal-image');
            const modalText = document.getElementById('modal-text');
            
            modalTitle.textContent = data.name;
            modalImage.style = data.imageStyle;
            modalImage.textContent = data.name;
            modalText.textContent = data.description;
            
            modal.style.display = 'flex';
            currentModalCube = cubeIndex;
        }

        function setupCubeInteractions() {
            const canvas = renderer.domElement;

            if (isMobile) {
                // Su mobile, usa touch events con detection del tap
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            } else {
                // Su desktop, usa click normale
                canvas.addEventListener('click', handleCanvasClick);
            }
        }

        function handleTouchStart(event) {
            const touch = event.touches[0];
            touchStartTime = Date.now();
            touchStartPos.x = touch.clientX;
            touchStartPos.y = touch.clientY;
            
            // Se non Ã¨ sul gamepad, gestisci come potenziale tap o rotazione
            const gamepad = document.getElementById('gamepad');
            const gamepadRect = gamepad.getBoundingClientRect();
            
            if (touch.clientX >= gamepadRect.left && 
                touch.clientX <= gamepadRect.right &&
                touch.clientY >= gamepadRect.top && 
                touch.clientY <= gamepadRect.bottom) {
                // Tocca sul gamepad - non fare nulla qui, sarÃ  gestito dal gamepad
                return;
            }
            
            // Altrimenti, potrebbe essere un tap o l'inizio di una rotazione
            event.preventDefault();
        }

        function handleTouchEnd(event) {
            const touch = event.changedTouches[0];
            const currentTime = Date.now();
            const touchDuration = currentTime - touchStartTime;
            
            // Calcola la distanza del movimento
            const deltaX = Math.abs(touch.clientX - touchStartPos.x);
            const deltaY = Math.abs(touch.clientY - touchStartPos.y);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Se Ã¨ un tap (breve durata e poco movimento)
            if (touchDuration < TAP_MAX_DURATION && distance < TAP_MAX_DISTANCE) {
                handleCubeTap(touch.clientX, touch.clientY);
            }
            
            event.preventDefault();
        }

        function handleCubeTap(clientX, clientY) {
            // Calcola la posizione del touch in coordinate normalizzate (-1 to +1)
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (clientY / window.innerHeight) * 2 + 1;

            // Aggiorna il raycaster con la posizione della camera e del mouse
            raycaster.setFromCamera(mouse, camera);

            // Calcola gli oggetti che intersecano il raycaster
            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                // Un cubo Ã¨ stato toccato, apri la modale
                const cubeIndex = intersects[0].object.userData.index;
                showModal(cubeIndex);
                highlightSelectedCube(cubeIndex);
            }
        }

        function handleCanvasClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                const cubeIndex = intersects[0].object.userData.index;
                showModal(cubeIndex);
                highlightSelectedCube(cubeIndex);
            }
        }

        function setupGamepad() {
            const gamepad = document.getElementById('gamepad');
            const stick = document.getElementById('stick');

            function startDrag(e) {
                isDragging = true;
                e.preventDefault();
            }

            function moveDrag(e) {
                if (!isDragging) return;
                
                const touch = e.touches ? e.touches[0] : e;
                const rect = gamepad.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxDistance;
                    dy = Math.sin(angle) * maxDistance;
                }
                
                stickPos.x = dx;
                stickPos.y = dy;
                
                stick.style.transform = `translate(${dx}px, ${dy}px)`;
                
                velocity.x = dx / maxDistance * 0.15;
                velocity.z = dy / maxDistance * 0.15;
                
                e.preventDefault();
            }

            function endDrag() {
                isDragging = false;
                stickPos.x = 0;
                stickPos.y = 0;
                stick.style.transform = 'translate(0, 0)';
                velocity.x = 0;
                velocity.z = 0;
            }

            // Mouse events
            stick.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', moveDrag);
            document.addEventListener('mouseup', endDrag);

            // Touch events
            stick.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', moveDrag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function setupCameraRotation() {
            const canvas = renderer.domElement;
            
            function startRotation(e) {
                // Su mobile, ignora se si tocca il gamepad
                if (isMobile) {
                    const gamepadRect = document.getElementById('gamepad').getBoundingClientRect();
                    const touch = e.touches ? e.touches[0] : e;
                    
                    if (touch.clientX >= gamepadRect.left && 
                        touch.clientX <= gamepadRect.right &&
                        touch.clientY >= gamepadRect.top && 
                        touch.clientY <= gamepadRect.bottom) {
                        return;
                    }
                }
                
                isRotating = true;
                lastTouchPos.x = e.touches ? e.touches[0].clientX : e.clientX;
                lastTouchPos.y = e.touches ? e.touches[0].clientY : e.clientY;
                e.preventDefault();
            }
            
            function moveRotation(e) {
                if (!isRotating) return;
                
                const touch = e.touches ? e.touches[0] : e;
                const deltaX = touch.clientX - lastTouchPos.x;
                const deltaY = touch.clientY - lastTouchPos.y;
                
                cameraRotation.yaw -= deltaX * 0.003;
                cameraRotation.pitch -= deltaY * 0.003;
                
                // Limit pitch to prevent flipping
                cameraRotation.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.pitch));
                
                lastTouchPos.x = touch.clientX;
                lastTouchPos.y = touch.clientY;
                
                e.preventDefault();
            }
            
            function endRotation() {
                isRotating = false;
            }
            
            // Mouse events per desktop
            canvas.addEventListener('mousedown', startRotation);
            document.addEventListener('mousemove', moveRotation);
            document.addEventListener('mouseup', endRotation);
            
            // Touch events per mobile - SEMPRE ATTIVI
            canvas.addEventListener('touchstart', startRotation, { passive: false });
            document.addEventListener('touchmove', moveRotation, { passive: false });
            document.addEventListener('touchend', endRotation);
        }

        function updateDesktopMovement() {
            if (!isMobile) {
                velocity.x = 0;
                velocity.z = 0;
                
                const speed = 0.1;
                
                if (keys.w) velocity.z = -speed;
                if (keys.s) velocity.z = speed;
                if (keys.a) velocity.x = -speed;
                if (keys.d) velocity.x = speed;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotation.yaw;
            camera.rotation.x = cameraRotation.pitch;

            // Aggiorna movimento per desktop
            updateDesktopMovement();

            // Calculate movement direction based on camera rotation
            const forward = new THREE.Vector3(
                Math.sin(cameraRotation.yaw),
                0,
                Math.cos(cameraRotation.yaw)
            );
            const right = new THREE.Vector3(
                Math.cos(cameraRotation.yaw),
                0,
                -Math.sin(cameraRotation.yaw)
            );

            // Update player position based on camera direction
            playerPos.x += forward.x * velocity.z + right.x * velocity.x;
            playerPos.z += forward.z * velocity.z + right.z * velocity.x;

            // Update camera position
            camera.position.x = playerPos.x;
            camera.position.z = playerPos.z;

            // Animazione dei cubi
            cubes.forEach((cube, index) => {
                cube.rotation.y += 0.01;
                cube.rotation.x += 0.005;
                
                // Animazione delle luci (pulsazione leggera)
                if (cubeLights[index]) {
                    const intensity = 0.5 + Math.sin(Date.now() * 0.001 + index) * 0.1;
                    cubeLights[index].intensity = intensity;
                }
            });

            renderer.render(scene, camera);

            // Nascondi il loader dopo il primo render completato
            if (!firstRenderDone) {
                firstRenderDone = true;
                setTimeout(hideLoader, 1000);
            }
        }

        function onWindowResize() {
            isMobile = window.innerWidth <= 768;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Inizia il preload e l'inizializzazione
        init();
    </script>
</body>
</html>